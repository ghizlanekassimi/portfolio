{"ast":null,"code":"import { invariant } from 'hey-listen';\nimport { animateVisualElement, stopAnimation } from '../../render/utils/animation.mjs';\nimport { setValues } from '../../render/utils/setters.mjs';\n/**\n * @public\n */\n\nfunction animationControls() {\n  /**\n   * Track whether the host component has mounted.\n   */\n  let hasMounted = false;\n  /**\n   * A collection of linked component animation controls.\n   */\n\n  const subscribers = new Set();\n  const controls = {\n    subscribe(visualElement) {\n      subscribers.add(visualElement);\n      return () => void subscribers.delete(visualElement);\n    },\n\n    start(definition, transitionOverride) {\n      invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      const animations = [];\n      subscribers.forEach(visualElement => {\n        animations.push(animateVisualElement(visualElement, definition, {\n          transitionOverride\n        }));\n      });\n      return Promise.all(animations);\n    },\n\n    set(definition) {\n      invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(visualElement => {\n        setValues(visualElement, definition);\n      });\n    },\n\n    stop() {\n      subscribers.forEach(visualElement => {\n        stopAnimation(visualElement);\n      });\n    },\n\n    mount() {\n      hasMounted = true;\n      return () => {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n\n  };\n  return controls;\n}\n\nexport { animationControls };","map":{"version":3,"sources":["D:/Documents/GI4/s7/React/portfolio-ghiz/node_modules/framer-motion/dist/es/animation/hooks/animation-controls.mjs"],"names":["invariant","animateVisualElement","stopAnimation","setValues","animationControls","hasMounted","subscribers","Set","controls","subscribe","visualElement","add","delete","start","definition","transitionOverride","animations","forEach","push","Promise","all","set","stop","mount"],"mappings":"AAAA,SAASA,SAAT,QAA0B,YAA1B;AACA,SAASC,oBAAT,EAA+BC,aAA/B,QAAoD,kCAApD;AACA,SAASC,SAAT,QAA0B,gCAA1B;AAEA;AACA;AACA;;AACA,SAASC,iBAAT,GAA6B;AACzB;AACJ;AACA;AACI,MAAIC,UAAU,GAAG,KAAjB;AACA;AACJ;AACA;;AACI,QAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;AACA,QAAMC,QAAQ,GAAG;AACbC,IAAAA,SAAS,CAACC,aAAD,EAAgB;AACrBJ,MAAAA,WAAW,CAACK,GAAZ,CAAgBD,aAAhB;AACA,aAAO,MAAM,KAAKJ,WAAW,CAACM,MAAZ,CAAmBF,aAAnB,CAAlB;AACH,KAJY;;AAKbG,IAAAA,KAAK,CAACC,UAAD,EAAaC,kBAAb,EAAiC;AAClCf,MAAAA,SAAS,CAACK,UAAD,EAAa,iHAAb,CAAT;AACA,YAAMW,UAAU,GAAG,EAAnB;AACAV,MAAAA,WAAW,CAACW,OAAZ,CAAqBP,aAAD,IAAmB;AACnCM,QAAAA,UAAU,CAACE,IAAX,CAAgBjB,oBAAoB,CAACS,aAAD,EAAgBI,UAAhB,EAA4B;AAC5DC,UAAAA;AAD4D,SAA5B,CAApC;AAGH,OAJD;AAKA,aAAOI,OAAO,CAACC,GAAR,CAAYJ,UAAZ,CAAP;AACH,KAdY;;AAebK,IAAAA,GAAG,CAACP,UAAD,EAAa;AACZd,MAAAA,SAAS,CAACK,UAAD,EAAa,+GAAb,CAAT;AACA,aAAOC,WAAW,CAACW,OAAZ,CAAqBP,aAAD,IAAmB;AAC1CP,QAAAA,SAAS,CAACO,aAAD,EAAgBI,UAAhB,CAAT;AACH,OAFM,CAAP;AAGH,KApBY;;AAqBbQ,IAAAA,IAAI,GAAG;AACHhB,MAAAA,WAAW,CAACW,OAAZ,CAAqBP,aAAD,IAAmB;AACnCR,QAAAA,aAAa,CAACQ,aAAD,CAAb;AACH,OAFD;AAGH,KAzBY;;AA0Bba,IAAAA,KAAK,GAAG;AACJlB,MAAAA,UAAU,GAAG,IAAb;AACA,aAAO,MAAM;AACTA,QAAAA,UAAU,GAAG,KAAb;AACAG,QAAAA,QAAQ,CAACc,IAAT;AACH,OAHD;AAIH;;AAhCY,GAAjB;AAkCA,SAAOd,QAAP;AACH;;AAED,SAASJ,iBAAT","sourcesContent":["import { invariant } from 'hey-listen';\nimport { animateVisualElement, stopAnimation } from '../../render/utils/animation.mjs';\nimport { setValues } from '../../render/utils/setters.mjs';\n\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false;\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set();\n    const controls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement);\n            return () => void subscribers.delete(visualElement);\n        },\n        start(definition, transitionOverride) {\n            invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            const animations = [];\n            subscribers.forEach((visualElement) => {\n                animations.push(animateVisualElement(visualElement, definition, {\n                    transitionOverride,\n                }));\n            });\n            return Promise.all(animations);\n        },\n        set(definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition);\n            });\n        },\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement);\n            });\n        },\n        mount() {\n            hasMounted = true;\n            return () => {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls };\n"]},"metadata":{},"sourceType":"module"}