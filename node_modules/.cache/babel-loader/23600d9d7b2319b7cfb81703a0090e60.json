{"ast":null,"code":"import { useRef, useCallback } from 'react';\nimport { isNodeOrChild } from './utils/is-node-or-child.mjs';\nimport { addPointerEvent, usePointerEvent } from '../events/use-pointer-event.mjs';\nimport { useUnmountEffect } from '../utils/use-unmount-effect.mjs';\nimport { AnimationType } from '../render/utils/types.mjs';\nimport { isDragActive } from './drag/utils/lock.mjs';\nimport { pipe } from '../utils/pipe.mjs';\n/**\n * @param handlers -\n * @internal\n */\n\nfunction useTapGesture(_ref) {\n  let {\n    onTap,\n    onTapStart,\n    onTapCancel,\n    whileTap,\n    visualElement,\n    ...props\n  } = _ref;\n  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  const isPressing = useRef(false);\n  const cancelPointerEndListeners = useRef(null);\n  /**\n   * Only set listener to passive if there are no external listeners.\n   */\n\n  const eventOptions = {\n    passive: !(onTapStart || onTap || onTapCancel || props[\"onPointerDown\"])\n  };\n\n  function removePointerEndListener() {\n    cancelPointerEndListeners.current && cancelPointerEndListeners.current();\n    cancelPointerEndListeners.current = null;\n  }\n\n  function checkPointerEnd() {\n    removePointerEndListener();\n    isPressing.current = false;\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, false);\n    return !isDragActive();\n  }\n\n  function onPointerUp(event, info) {\n    if (!checkPointerEnd()) return;\n    /**\n     * We only count this as a tap gesture if the event.target is the same\n     * as, or a child of, this component's element\n     */\n\n    !isNodeOrChild(visualElement.current, event.target) ? onTapCancel && onTapCancel(event, info) : onTap && onTap(event, info);\n  }\n\n  function onPointerCancel(event, info) {\n    if (!checkPointerEnd()) return;\n    onTapCancel && onTapCancel(event, info);\n  }\n\n  const startPress = useCallback((event, info) => {\n    removePointerEndListener();\n    if (isPressing.current) return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n    /**\n     * Ensure we trigger animations before firing event callback\n     */\n\n    visualElement.animationState && visualElement.animationState.setActive(AnimationType.Tap, true);\n    onTapStart && onTapStart(event, info);\n  }, [onTapStart, visualElement]);\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? startPress : undefined, eventOptions);\n  useUnmountEffect(removePointerEndListener);\n}\n\nexport { useTapGesture };","map":{"version":3,"sources":["D:/Documents/GI4/s7/React/portfolio-ghiz/node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs"],"names":["useRef","useCallback","isNodeOrChild","addPointerEvent","usePointerEvent","useUnmountEffect","AnimationType","isDragActive","pipe","useTapGesture","onTap","onTapStart","onTapCancel","whileTap","visualElement","props","hasPressListeners","isPressing","cancelPointerEndListeners","eventOptions","passive","removePointerEndListener","current","checkPointerEnd","animationState","setActive","Tap","onPointerUp","event","info","target","onPointerCancel","startPress","window","undefined"],"mappings":"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","sourcesContent":["import { useRef, useCallback } from 'react';\nimport { isNodeOrChild } from './utils/is-node-or-child.mjs';\nimport { addPointerEvent, usePointerEvent } from '../events/use-pointer-event.mjs';\nimport { useUnmountEffect } from '../utils/use-unmount-effect.mjs';\nimport { AnimationType } from '../render/utils/types.mjs';\nimport { isDragActive } from './drag/utils/lock.mjs';\nimport { pipe } from '../utils/pipe.mjs';\n\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement, ...props }) {\n    const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    const isPressing = useRef(false);\n    const cancelPointerEndListeners = useRef(null);\n    /**\n     * Only set listener to passive if there are no external listeners.\n     */\n    const eventOptions = {\n        passive: !(onTapStart ||\n            onTap ||\n            onTapCancel ||\n            props[\"onPointerDown\"]),\n    };\n    function removePointerEndListener() {\n        cancelPointerEndListeners.current && cancelPointerEndListeners.current();\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        removePointerEndListener();\n        isPressing.current = false;\n        visualElement.animationState &&\n            visualElement.animationState.setActive(AnimationType.Tap, false);\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        if (!checkPointerEnd())\n            return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component's element\n         */\n        !isNodeOrChild(visualElement.current, event.target)\n            ? onTapCancel && onTapCancel(event, info)\n            : onTap && onTap(event, info);\n    }\n    function onPointerCancel(event, info) {\n        if (!checkPointerEnd())\n            return;\n        onTapCancel && onTapCancel(event, info);\n    }\n    const startPress = useCallback((event, info) => {\n        removePointerEndListener();\n        if (isPressing.current)\n            return;\n        isPressing.current = true;\n        cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n        /**\n         * Ensure we trigger animations before firing event callback\n         */\n        visualElement.animationState &&\n            visualElement.animationState.setActive(AnimationType.Tap, true);\n        onTapStart && onTapStart(event, info);\n    }, [onTapStart, visualElement]);\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? startPress : undefined, eventOptions);\n    useUnmountEffect(removePointerEndListener);\n}\n\nexport { useTapGesture };\n"]},"metadata":{},"sourceType":"module"}